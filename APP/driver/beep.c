#include "../main.h"

/************************************************************************/
/* 功能：蜂鸣器结构体
 * 描述：一次蜂鸣器任务周期是|---on---off---on---off---|
 * 形参：
 * 返回：               */
/************************************************************************/
static struct
{
	u16		delay;					//计时计数
	u16		delay_on;				//开启持续时间
	u16		delay_off;				//关闭持续时间

	//剩余的开启+关闭次数，该参数在每次开启的时候减1，最后一次开启时=0，表示已经没有次数可以开启了。
	//函数会在下一次关闭的时候删除自身。
	s8		times;
	s8		stat;			//蜂鸣器当前理论状态，蜂鸣器之前正在响/不响

	s8 		open;					//=1 打开中断开启蜂鸣器				
}beep;

/************************************************************************/
/* 功能：蜂鸣器复位
 * 描述：清除已经使能的蜂鸣器功能
 * 形参：
 * 返回：               */
/************************************************************************/
void beep_reset(void)
{
	beep.delay = 0;
	beep.delay_on = 0;
	beep.delay_off = 0;
	beep.times = 0;
	beep.stat = 0;
	beep.open = 0;
}

/************************************************************************/
/* 功能：蜂鸣器响
 * 描述：
 * 形参：开启的持续时间,关的持续时间，响次数(>0)
 * 返回：               */
/************************************************************************/
void beep_on(BEEP_t last,BEEP_t delay,s8 times)
{
	//现在的架构中，蜂鸣器是最后统一执行的。那么极有可能当前的蜂鸣器还没运行结束
	//下一个蜂鸣器的请求已经传入，那么可能会导致前一个蜂鸣器始终不会停止
	//一直长响中。因此，必须等当前蜂鸣器运行完才能接收下一个蜂鸣器任务
	if(beep.open)
		return;

	beep.delay_on  = last;
	beep.delay_off = delay;
	beep.times = times;
	beep.stat = 0;
	freq.delay_beep = beep.delay_on;
}

/************************************************************************/
/* 功能：蜂鸣器响,短响一声特供版
 * 描述：
 * 形参：
 * 返回：               */
/************************************************************************/
void beep_on_one(void)
{
//	beep_reset();
	beep_on(BEEP_SHORT,BEEP_OFF_SHORT,1);
}

/************************************************************************/
/* 功能：蜂鸣器响,长鸣特供版
 * 描述：当超出上限时，长鸣
 * 形参：
 * 返回：               */
/************************************************************************/
void beep_on_long(void)
{
	beep_reset();
	beep_on(BEEP_LONG,BEEP_OFF_MIDDLE,1);
}

/************************************************************************/
/* 功能：蜂鸣器响,警告特供版
 * 描述：当前按键不可用时
 * 形参：
 * 返回：               */
/************************************************************************/
void beep_on_alarm(void)
{
	beep_on(BEEP_SHORT,BEEP_OFF_SHORT,2);
}
/************************************************************************/
/* 功能：蜂鸣器任务，定时检查决定是否关闭
 * 描述：然后再在任务中判断beep的状态
 * 形参：
 * 返回：               */
/************************************************************************/
void task_beep(void)
{
	//if(beep.times > 0)			
	//	return;
  	if(freq.delay_beep)			//还在延时中，不运行
	  	return;


	//if(beep.stat)										//调用时候/之前蜂鸣器是响的，
	if(beep.open)
	{
		beep.open = 0;									//发送蜂鸣器关闭事件
		beep.stat = 0;									//报告蜂鸣器已经不响
		freq.delay_beep = beep.delay_off;				//赋值蜂鸣器不响的间隔是beep.off
	}
	//else if(beep.stat == 0)								//第一次/本次运行前，蜂鸣器没有响，那么检测是否能打开
	else if(beep.open == 0)
	{
		if(beep.times)									//次数还有，重启
		{
			beep.times--;									//本次次数减1
			beep.open = 1;								//发送蜂鸣器开始事件
			beep.stat = 1;								//报告蜂鸣器已经响了	
			freq.delay_beep = beep.delay_on;		//赋值本次开启的持续时间，即beep.on后再次运行判断
		}
	//	else											//没有次数l
	//	{
	//	  	beep.open = 0;						
	//	}
	}
}

void beep_init(void)
{
	beep.open = 0;
}

/************************************************************************/
/* 功能：蜂鸣器处理
 * 描述：放在125us中断中
 * 形参：
 * 返回：          */
/************************************************************************/
void interrupt_beep(void)
{
  	if(beep.open) 
	{
		if (PORTD&0x40)
		{
			PORTD &=~0x40;
		}
		else
		{
			PORTD |=0x40;
		}
	}
	else if(ext.alarm_beep)
	{
		if (PORTD&0x40)
		{
			PORTD &=~0x40;
		}
		else
		{
			PORTD |=0x40;
		}
	}
}